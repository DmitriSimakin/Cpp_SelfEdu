// Начиная с C++11 появились лямбда-функции
// [] ([параметры]) {<операторы тела функции>}
// для чего используюся []?
/*
Через них можно передавать внешние переменные из 
внешней области видимости (т.е. переменные, находящиеся за пределами тела лямбда-функции)
- этот процесс наз. захват переменных.
*/

#include <iostream>
#include <string>

using std::cout;
using std::cin;
using std::endl;

const int max_size = 1000;  // глобальная перемнная

int main()
{
   int data[] {1, 2, 3, 4, 5, 6, 7, 8};
   size_t sz = sizeof(data)/sizeof(*data);

   // auto r = [] () 
   //          {
   //             cout << sz << endl; // локал. переменная недоступна внутри тела лямбда-функции.
   //             cout << max_size << endl;
   //          };

/*
=  - означает, что мы копируем все значения локальных переменных в КОНСТАНТНЫЕ переменные
кот. автоматически создаются внутри тела лямбда-функции с теми же именами. 
*/
   // auto r = [=] () 
   //          {
   //             cout << sz << endl; // локал. переменная недоступна внутри тела лямбда-функции.
   //             cout << max_size << endl;
   //             // sz++; // нельзя
   //                max_size++;
   //          };

   // r();

/*
Но чтобы копировать не в константные переменные, можно добавить 
ключевое слово mutable:
*/
   // auto r = [=] () mutable 
   //          {
   //             sz++;  // эта не та же переменная, что в main()
   //             cout << sz << endl; // локал. переменная недоступна внутри тела лямбда-функции.
   //             cout << max_size << endl;
   //             // max_size++; // глобальные нельзя менять.
   //          };
   // r();
   // cout << sz << endl;

// аналогично с массивом:
   // auto r = [=] () mutable 
   //          {
   //             for(int& x : data)
   //             {
   //                x += 2;
   //                cout << x << " ";
   //             }
   //             cout << endl;
   //             cout << max_size << endl;
      
   //          };
   // r();
   // cout << sz << endl;

// копируем только sz и data:
   // auto r = [sz, data] () mutable 
   //          {
   //             for(int& x : data)
   //             {
   //                x += 2;
   //                cout << x << " ";
   //             }
   //             cout << endl;
   //             cout << max_size << endl;
      
   //          };
   // r();
   // cout << sz << endl;

// Чтобы менять значения через анонимные функции нужно передавать значения по ссылке:
// аналогично можно передавать только выделенные локальные переменные (их ссылки): &sz, &data
// в случае передачи по ссылкам mutable можно не писать.
   // auto r = [&] ()
   //          {
   //             for(int& x : data)
   //                x += 2;
   //             cout << endl;
   //             cout << max_size << endl;
      
   //          };
   // r();
   // for(int& x : data)
   //    cout << x << " ";

// Всё работает и с указателями:
   size_t* ptr_sz = &sz;

   auto r = [ptr_sz, &data] ()
            {
               (*ptr_sz)++;
               // ptr_sz++; // нельзя, т.к. он константный, но с помощью mutable можно
            };
   r();
   cout << sz << endl;

   // Примеры:
   /*
   [&a, b, &m, n]  // a и m - по ссылке, b и n - по значению.
   [=, &m, &n] // всё по значению, m и n - по ссылке.
   [&, m, n] // всё по ссылке, m и n - по значению.   
   */

   return 0;
}